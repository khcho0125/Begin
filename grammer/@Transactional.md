# Transactional 어노테이션

@Transactional 어노테이션을 활용하기 전에 먼저 '트랜잭션'에 대해 알아봐야한다.

## 트랜잭션이란?

트랜잭션은 DB의 상태를 변경하는 작업 또는 한번에 수행해야할 연산을 말한다.

트랜잭션은 4가지의 특성을 가지고 있다.

1. 원자성(Atomicity)

한 트랜잭션 내에서 실행한 작업의 결과는 모두 성공 또는 모두 실패이다.

2. 일관성(Consistency)

트랜잭션은 일관성있는 DB 상태를 유지한다.

데이터 베이스의 무결성을 지킨다고 할 수 있다.

3. 격리성(Isolation)

동시에 실행되는 트랜잭션들이 서로 영향을 미칠 수 없어야 한다.

4. 영속성(Durability)

트랜잭션을 성공적으로 마치면 결과가 항상 저장되어야 한다.

## 본격적으로 @Transactional 어노테이션을 알아보도록 하자

### 옵션

### 1. isolation

일관성없는 데이터 허용 단계를 설정한다.

* #### READ_UNCOMMITED

처리 중이나 커밋되지 않은 트랜잭션의 데이터를 다른 트랜잭션이 읽는 것을 허용

A 트랜잭션이 작업 중인 C 데이터를 B 트랜잭션이 변경되지 않은 C 데이터를 읽는 것이다.

Dirty Read 발생 (데이터 정합성 오류)

* #### READ_COMMITED

트랜잭션이 커밋된 데이터만 읽을 수 있도록 허용

A 라는 데이터가 B로 변경되는 동안 다른 사용자가 읽을 수 없음

Dirty Read 방지

* #### REPEATABLE_READ

트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 shared Lock이 걸린다.

다른 사용자가 트랜잭션에 침범할 수 없음을 말한다.

두 번 쿼리했을 때 일관성있는 결과를 보여준다.

* #### SERIALIZABLE

데이터의 일관성과 동시성을 위해 MVCC(Multi Version Concurrency Control)을 사용하지 않는다.

성능 측면에서 가장 동시 처리 성능이 낮음

성능 저하 우려 + 거의 사용되지 않음

### 2. propagation

트랜잭션 동작 도중 다른 트랜잭션을 호출할 때의 설정이다.

* #### REQUIRED (default)

이미 진행 중인 트랜잭션이 있다면 진행 중인 트랜잭션 내에서 트랜잭션 실행, 아니라면 새로운 트랜잭션 실행

예외가 발생하면 롤백 + 부모 트랜잭션도 롤백

* #### REQUIRES_NEW

매번 새로운 트랜잭션을 실행한다.

예외가 발생해도 다른 트랜잭션으로 롤백이 전파되지 않는다.

* #### NESTED

부모 트랜잭션에서 진행될 경우 별개로 커밋되거나 진행될 수 있다.

REQUIRED와 동일하지만 SAVEPOINT를 지정한 부분까지 부분 롤백이 가능하다는 점이 다르다.

* #### MANDATORY

부모 트랜잭션 내에서 실행되며, 부모 트랜잭션이 없을 경우 Exception이 발생된다.

* #### SUPPORT

이미 시작된 트랜잭션이 있으면 그 트랜잭션 속성을 따르고, 없으면 트랜잭션을 설정하지 않는다.

* #### NOT_SUPPORT

이미 진행중인 트랜잭션이 있다면 보류하고, 트랜잭션없이 작업을 수행한다.

* #### NEVER

트랜잭션이 없을 때 실행되며 부모 트랜잭션이 존재하면 Exception이 발생한다.

### 3. noRollbackFor

예외발생시 롤백하지 않음

### 4. RollbackFor

예외 발생시 롤백

@Transactional은 기본적으로 Unchecked Exception과 Error만 롤백하는데 모든 예외를 롤백하고 싶다면 사용한다.

### 5. timeout

지정한 시간내에 메소드 수행이 끝나지 않을 경우 롤백 수행

-1로 설정시 notimeout

### 6. readOnly

true시 insert, update, delete 실행시 예외 발생
